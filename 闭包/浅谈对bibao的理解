谈谈自己的理解:python中闭包，闭包的实质
请大家跟我理解一下，如果在一个函数的内部定义了另一个函数，外部的我们叫他外函数，内部的我们叫他内函数。
闭包： 

　　在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。

一般情况下，在我们认知当中，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。

复制代码
复制代码
 1 #闭包函数的实例
 2 # outer是外部函数 a和b都是外函数的临时变量
 3 def outer( a ):
 4     b = 10
 5     # inner是内函数
 6     def inner():
 7         #在内函数中 用到了外函数的临时变量
 8         print(a+b)
 9     # 外函数的返回值是内函数的引用
10     return inner
11 
12 if __name__ == '__main__':
13     # 在这里我们调用外函数传入参数5
14     #此时外函数两个临时变量 a是5 b是10 ，并创建了内函数，然后把内函数的引用返回存给了demo
15     # 外函数结束的时候发现内部函数将会用到自己的临时变量，这两个临时变量就不会释放，会绑定给这个内部函数
16     demo = outer(5)
17     # 我们调用内部函数，看一看内部函数是不是能使用外部函数的临时变量
18     # demo存了外函数的返回值，也就是inner函数的引用，这里相当于执行inner函数
19     demo() # 15
20 
21     demo2 = outer(7)
22     demo2()#17
复制代码
复制代码
 

从上面例子是我写的一个最简单的很典型的闭包。我估计如果是初学的小伙伴，可能很多名词都不明白是什么意思，没关系，我把这些名词按照自己的理解去解释一下~

1 外函数返回了内函数的引用：

　　引用是什么？在python中一切都是对象，包括整型数据1，函数，其实是对象。

　　当我们进行a=1的时候，实际上在内存当中有一个地方存了值1，然后用a这个变量名存了1所在内存位置的引用。引用就好像c语言里的指针，大家可以把引用理解成地址。a只不过是一个变量名字，a里面存的是1这个数值所在的地址，就是a里面存了数值1的引用。

　　相同的道理，当我们在python中定义一个函数def demo():  的时候，内存当中会开辟一些空间，存下这个函数的代码、内部的局部变量等等。这个demo只不过是一个变量名字，它里面存了这个函数所在位置的引用而已。我们还可以进行x = demo， y = demo， 这样的操作就相当于，把demo里存的东西赋值给x和y，这样x 和y 都指向了demo函数所在的引用，在这之后我们可以用x() 或者 y() 来调用我们自己创建的demo() ，调用的实际上根本就是一个函数，x、y和demo三个变量名存了同一个函数的引用。

　　不知道大家有没有理解，很晦涩，希望我说明白了我想表达的。

　　有了上面的解释，我们可以继续说，返回内函数的引用是怎么回事了。对于闭包，在外函数outer中 最后return inner，我们在调用外函数 demo = outer() 的时候，outer返回了inner，inner是一个函数的引用，这个引用被存入了demo中。所以接下来我们再进行demo() 的时候，相当于运行了inner函数。

　　同时我们发现，一个函数，如果函数名后紧跟一对括号，相当于现在我就要调用这个函数，如果不跟括号，相当于只是一个函数的名字，里面存了函数所在位置的引用。

2 外函数把临时变量绑定给内函数：

　　按照我们正常的认知，一个函数结束的时候，会把自己的临时变量都释放还给内存，之后变量都不存在了。一般情况下，确实是这样的。但是闭包是一个特别的情况。外部函数发现，自己的临时变量会在将来的内部函数中用到，自己在结束的时候，返回内函数的同时，会把外函数的临时变量送给内函数绑定在一起。所以外函数已经结束了，调用内函数的时候仍然能够使用外函数的临时变量。

　　在我编写的实例中，我两次调用外部函数outer,分别传入的值是5和7。内部函数只定义了一次，我们发现调用的时候，内部函数是能识别外函数的临时变量是不一样的。python中一切都是对象，虽然函数我们只定义了一次，但是外函数在运行的时候，实际上是按照里面代码执行的，外函数里创建了一个函数，我们每次调用外函数，它都创建一个内函数，虽然代码一样，但是却创建了不同的对象，并且把每次传入的临时变量数值绑定给内函数，再把内函数引用返回。虽然内函数代码是一样的，但其实，我们每次调用外函数，都返回不同的实例对象的引用，他们的功能是一样的，但是它们实际上不是同一个函数对象。

 

闭包中内函数修改外函数局部变量：

　　在闭包内函数中，我们可以随意使用外函数绑定来的临时变量，但是如果我们想修改外函数临时变量数值的时候发现出问题了！咋回事捏？？！！（哇哇大哭）

　　在基本的python语法当中，一个函数可以随意读取全局数据，但是要修改全局数据的时候有两种方法:1 global 声明全局变量 2 全局变量是可变类型数据的时候可以修改

　　在闭包内函数也是类似的情况。在内函数中想修改闭包变量（外函数绑定给内函数的局部变量）的时候：

　　　　1 在python3中，可以用nonlocal 关键字声明 一个变量， 表示这个变量不是局部变量空间的变量，需要向上一层变量空间找这个变量。

　　　　2 在python2中，没有nonlocal这个关键字，我们可以把闭包变量改成可变类型数据进行修改，比如列表。

上代码！！！

复制代码
复制代码
 1 #修改闭包变量的实例
 2 # outer是外部函数 a和b都是外函数的临时变量
 3 def outer( a ):
 4     b = 10  # a和b都是闭包变量
 5     c = [a] #这里对应修改闭包变量的方法2
 6     # inner是内函数
 7     def inner():
 8         #内函数中想修改闭包变量
 9         # 方法1 nonlocal关键字声明
10         nonlocal  b
11         b+=1
12         # 方法二，把闭包变量修改成可变数据类型 比如列表
13         c[0] += 1
14         print(c[0])
15         print(b)
16     # 外函数的返回值是内函数的引用
17     return inner
18 
19 if __name__ == '__main__':
20 
21     demo = outer(5)
22     demo() # 6  11
复制代码
复制代码
从上面代码中我们能看出来，在内函数中，分别对闭包变量进行了修改，打印出来的结果也确实是修改之后的结果。以上两种方法就是内函数修改闭包变量的方法。

 

还有一点需要注意：使用闭包的过程中，一旦外函数被调用一次返回了内函数的引用，虽然每次调用内函数，是开启一个函数执行过后消亡，但是闭包变量实际上只有一份，每次开启内函数都在使用同一份闭包变量

上代码！

复制代码
复制代码
 1 #coding:utf8
 2 def outer(x):
 3     def inner(y):
 4         nonlocal x
 5         x+=y
 6         return x
 7     return inner
 8 
 9 
10 a = outer(10)
11 print(a(1)) //11
12 print(a(3)) //14
复制代码
复制代码
两次分别打印出11和14，由此可见，每次调用inner的时候，使用的闭包变量x实际上是同一个。

 

 

 

 

 

闭包有啥用？？！！

　　很多伙伴很糊涂，闭包有啥用啊？？还这么难懂！

　　 3.1装饰器！！！装饰器是做什么的？？其中一个应用就是，我们工作中写了一个登录功能，我们想统计这个功能执行花了多长时间，我们可以用装饰器装饰这个登录模块，装饰器帮我们完成登录函数执行之前和之后取时间。

　　 3.2面向对象！！！经历了上面的分析，我们发现外函数的临时变量送给了内函数。大家回想一下类对象的情况，对象有好多类似的属性和方法，所以我们创建类，用类创建出来的对象都具有相同的属性方法。闭包也是实现面向对象的方法之一。在python当中虽然我们不这样用，在其他编程语言入比如avaScript中，经常用闭包来实现面向对象编程

　　 3.3实现单利模式！！ 其实这也是装饰器的应用。单利模式毕竟比较高大，，需要有一定项目经验才能理解单利模式到底是干啥用的，我们就不探讨了













def test():
    funcs = []
    for i in range(1,4):
        def test2():
            print(i)
        funcs.append(test2)
    return funcs
 
newFuncs = test()
newFuncs[0]() # 3
newFuncs[1]() # 3
newFuncs[2]() # 3
为什么输出的是333而不是123呢？实际上，newFuncs在获得test()返回的函数地址后，包含的三个存储为列表形式的函数地址的确是指向三个不同内存地址的，但是这三个内存地址指向的不同状态下的三个test2()却指向了同一个i，即for循环的最后一次循环i=3。为什么都指向同一个i=3呢？这是因为，在外层test()中，每一次for循环都定义了一个新的test2()，但此时内层函数test2()内i的值却从未传入过，还只是一个变量标识而已。最后一次循环i的值是3，因此在newFuncs[0]()这一步时，进入相应的内存地址指向的print(i)，这是内层函数开始引用i的值了，而此时i早已是3了，所以内层函数直接引用到了i=3这个结果。

为方便验证，在原来的代码中加入两行输出i的地址：

def test():
    funcs = []
    for i in range(1,4):
        def test2():
            print(i)
            print(id(i)) # 内层函数引用的i的地址
        funcs.append(test2)
        print(id(i))  # for循环时i的地址
    return funcs
 
newFuncs = test()
newFuncs[0]()
newFuncs[1]()
newFuncs[2]()
运行一下：

140730656088912
140730656088944
140730656088976
3
140730656088976
3
140730656088976
3
140730656088976
可以发现for循环时i的地址是变化的，而调用到内层函数引用i的值值，往外层寻找i只能寻找到最后一次for循环也就是i=3时的地址了。但是注意，尽管如此，外层函数每次return的函数地址也是不一样的。

那如何改才能使输出的i是123而不是333呢？

def test():
    funcs = []
    for i in range(1,4):
        def test2(num):
            def inner():
                print(num)
            return inner
        funcs.append(test2(i))
    return funcs
 
newFuncs = test()
newFuncs[0]()  # 1
newFuncs[1]()  # 2
newFuncs[2]()  # 3
如此修改后，funcs.append(test2(i))添加的是test2(i)函数的返回值，也就是inner的地址。而每次test2(i)返回的时候可是带有输入i的，这样内层函数inner就知道自己要引用的外层变量是什么了。这样newFuncs列表里存储的每个地址指向的内层函数inner就可以print出当时引用到的外层变量i了。

总结一下，闭包返回的是函数地址（所以返回的时候没有括号！），而非函数对象。对于某一外层函数输入状态下的闭包返回函数，其地址指向的内层函数引用的所有外层、内层的变量和表达式都是当时状态下固定好了的

